<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="sort.js"></script>
</head>
<body>
<script>
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
 const maxSlidingWindow = function (nums, k) {
  if (!nums || nums.length < 2) {
    return nums
  }
  // 缓存数组长度
  let len = nums.length
  // 结果数组
  let res = []
  // 双端队列,存储的是数组下标
  let que = []
  for (let i = 0; i < len; i++) {
    // 检查当前元素，是否大于队尾元素，是则que出队，直到满足que递减
    while (que.length && nums[i] > nums[que[que.length - 1]]) {
      que.pop()
    }
    // 入队
    que.push(i)
    // 检查队头元素是否在滑动窗口内
    while (que[0] <= i - k) {
      que.shift()
    }
    // 未初始化完成的情况
    if (i >= k -1) {
      res.push(nums[que[0]])
    }
  }
  return res
 }
 console.log('maxSlidingWindow', maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3))

 /**
 * @param {number[]} nums
 * @return {number[][]}
 */
// 入参是一个数组
const permute = function(nums) {
  // 存储数组长度
  let len = nums.length
  // 结果数组
  let result = []
  if (len === 0) {
    return nums
  }
  // 记录数字是否使用过
  let visited = {}
  // 当前左右的排列顺序
  let cur = []
  // 当前的排列内容
  function dfs(nth) {
    if (nth === len) {
      // 深拷贝
      result.push(cur.slice())
      return
    }
    for (let i = 0; i < len; i++) {
      // 已经用过的数字不再占坑
      if (visited[nums[i]]) {
        continue
      }
      // 推入当前顺序
      cur.push(nums[i])
      // 标记已使用
      visited[nums[i]] = true
      // 基于这个坑，继续下一个坑
      dfs(nth+1)
      // 回溯
      cur.pop()
      // 重置状态
      visited[nums[i]] = false
    }
  }
  dfs(0)
  return result
}
console.log('permute:', permute([1,2,3]))

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
// 入参是一个数组
const subsets = function(nums) {
  let len = nums.length
  let result = []
  if (!len) {
    return result
  }
  // 组合数组
  let subset = []
  dfs(0)
  function dfs(index) {
    result.push(subset.slice())
    for (let i = index; i < len; i++) {
      subset.push(nums[i])
      dfs(i + 1)
      subset.pop()
    }
  }
  return result
}
console.log('subsets:', subsets([1,2,3]))
const levelOrder = function(root) {
  let res = []
  if(!root){
    return res
  }
  let queue = []
  queue.push(root)
  while(queue.length) {
    let level = []
    let len = queue.length
    for(let i = 0; i < len; i++){
      let top = queue.shift()
      level.push(top.val)
      top.left && queue.push(top.left)
      top.right && queue.push(top.right)
    }
    res.push(level)
  }
  return res
}
console.log('levelOrder:', levelOrder([3,9,20,null,null,15,7]))
</script>
</body>
</html>